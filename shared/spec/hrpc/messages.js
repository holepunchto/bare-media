// This file is autogenerated by the hyperschema compiler
// Schema Version: 3
/* eslint-disable camelcase */
/* eslint-disable quotes */
/* eslint-disable space-before-function-paren */

import { c } from 'hyperschema/runtime'

const VERSION = 3

// eslint-disable-next-line no-unused-vars
let version = VERSION

// @media/dimensions
const encoding0 = {
  preencode(state, m) {
    c.uint.preencode(state, m.width)
    c.uint.preencode(state, m.height)
  },
  encode(state, m) {
    c.uint.encode(state, m.width)
    c.uint.encode(state, m.height)
  },
  decode(state) {
    const r0 = c.uint.decode(state)
    const r1 = c.uint.decode(state)

    return {
      width: r0,
      height: r1
    }
  }
}

// @media/metadata.dimensions
const encoding1_1 = c.frame(encoding0)

// @media/metadata
const encoding1 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.mimetype) c.string.preencode(state, m.mimetype)
    if (m.dimensions) encoding1_1.preencode(state, m.dimensions)
    if (m.duration) c.uint.preencode(state, m.duration)
  },
  encode(state, m) {
    const flags = (m.mimetype ? 1 : 0) | (m.dimensions ? 2 : 0) | (m.duration ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.mimetype) c.string.encode(state, m.mimetype)
    if (m.dimensions) encoding1_1.encode(state, m.dimensions)
    if (m.duration) c.uint.encode(state, m.duration)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      mimetype: (flags & 1) !== 0 ? c.string.decode(state) : null,
      dimensions: (flags & 2) !== 0 ? encoding1_1.decode(state) : null,
      duration: (flags & 4) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @media/file.metadata
const encoding2_0 = c.frame(encoding1)

// @media/file
const encoding2 = {
  preencode(state, m) {
    state.end++ // max flag is 4 so always one byte

    if (m.metadata) encoding2_0.preencode(state, m.metadata)
    if (m.inlined) c.string.preencode(state, m.inlined)
    if (m.buffer) c.buffer.preencode(state, m.buffer)
  },
  encode(state, m) {
    const flags = (m.metadata ? 1 : 0) | (m.inlined ? 2 : 0) | (m.buffer ? 4 : 0)

    c.uint.encode(state, flags)

    if (m.metadata) encoding2_0.encode(state, m.metadata)
    if (m.inlined) c.string.encode(state, m.inlined)
    if (m.buffer) c.buffer.encode(state, m.buffer)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      metadata: (flags & 1) !== 0 ? encoding2_0.decode(state) : null,
      inlined: (flags & 2) !== 0 ? c.string.decode(state) : null,
      buffer: (flags & 4) !== 0 ? c.buffer.decode(state) : null
    }
  }
}

// @media/create-preview-request
const encoding3 = {
  preencode(state, m) {
    const flags =
      (m.path ? 1 : 0) |
      (m.httpLink ? 2 : 0) |
      (m.buffer ? 4 : 0) |
      (m.mimetype ? 8 : 0) |
      (m.maxWidth ? 16 : 0) |
      (m.maxHeight ? 32 : 0) |
      (m.maxFrames ? 64 : 0) |
      (m.maxBytes ? 128 : 0) |
      (m.format ? 256 : 0) |
      (m.encoding ? 512 : 0)

    c.uint.preencode(state, flags)

    if (m.path) c.string.preencode(state, m.path)
    if (m.httpLink) c.string.preencode(state, m.httpLink)
    if (m.buffer) c.buffer.preencode(state, m.buffer)
    if (m.mimetype) c.string.preencode(state, m.mimetype)
    if (m.maxWidth) c.uint.preencode(state, m.maxWidth)
    if (m.maxHeight) c.uint.preencode(state, m.maxHeight)
    if (m.maxFrames) c.uint.preencode(state, m.maxFrames)
    if (m.maxBytes) c.uint.preencode(state, m.maxBytes)
    if (m.format) c.string.preencode(state, m.format)
    if (m.encoding) c.string.preencode(state, m.encoding)
  },
  encode(state, m) {
    const flags =
      (m.path ? 1 : 0) |
      (m.httpLink ? 2 : 0) |
      (m.buffer ? 4 : 0) |
      (m.mimetype ? 8 : 0) |
      (m.maxWidth ? 16 : 0) |
      (m.maxHeight ? 32 : 0) |
      (m.maxFrames ? 64 : 0) |
      (m.maxBytes ? 128 : 0) |
      (m.format ? 256 : 0) |
      (m.encoding ? 512 : 0)

    c.uint.encode(state, flags)

    if (m.path) c.string.encode(state, m.path)
    if (m.httpLink) c.string.encode(state, m.httpLink)
    if (m.buffer) c.buffer.encode(state, m.buffer)
    if (m.mimetype) c.string.encode(state, m.mimetype)
    if (m.maxWidth) c.uint.encode(state, m.maxWidth)
    if (m.maxHeight) c.uint.encode(state, m.maxHeight)
    if (m.maxFrames) c.uint.encode(state, m.maxFrames)
    if (m.maxBytes) c.uint.encode(state, m.maxBytes)
    if (m.format) c.string.encode(state, m.format)
    if (m.encoding) c.string.encode(state, m.encoding)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      path: (flags & 1) !== 0 ? c.string.decode(state) : null,
      httpLink: (flags & 2) !== 0 ? c.string.decode(state) : null,
      buffer: (flags & 4) !== 0 ? c.buffer.decode(state) : null,
      mimetype: (flags & 8) !== 0 ? c.string.decode(state) : null,
      maxWidth: (flags & 16) !== 0 ? c.uint.decode(state) : 0,
      maxHeight: (flags & 32) !== 0 ? c.uint.decode(state) : 0,
      maxFrames: (flags & 64) !== 0 ? c.uint.decode(state) : 0,
      maxBytes: (flags & 128) !== 0 ? c.uint.decode(state) : 0,
      format: (flags & 256) !== 0 ? c.string.decode(state) : null,
      encoding: (flags & 512) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @media/create-preview-response.metadata
const encoding4_0 = encoding2_0
// @media/create-preview-response.preview
const encoding4_1 = c.frame(encoding2)

// @media/create-preview-response
const encoding4 = {
  preencode(state, m) {
    encoding4_0.preencode(state, m.metadata)
    encoding4_1.preencode(state, m.preview)
  },
  encode(state, m) {
    encoding4_0.encode(state, m.metadata)
    encoding4_1.encode(state, m.preview)
  },
  decode(state) {
    const r0 = encoding4_0.decode(state)
    const r1 = encoding4_1.decode(state)

    return {
      metadata: r0,
      preview: r1
    }
  }
}

// @media/decode-image-request
const encoding5 = {
  preencode(state, m) {
    state.end++ // max flag is 8 so always one byte

    if (m.path) c.string.preencode(state, m.path)
    if (m.httpLink) c.string.preencode(state, m.httpLink)
    if (m.buffer) c.buffer.preencode(state, m.buffer)
    if (m.mimetype) c.string.preencode(state, m.mimetype)
  },
  encode(state, m) {
    const flags =
      (m.path ? 1 : 0) | (m.httpLink ? 2 : 0) | (m.buffer ? 4 : 0) | (m.mimetype ? 8 : 0)

    c.uint.encode(state, flags)

    if (m.path) c.string.encode(state, m.path)
    if (m.httpLink) c.string.encode(state, m.httpLink)
    if (m.buffer) c.buffer.encode(state, m.buffer)
    if (m.mimetype) c.string.encode(state, m.mimetype)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      path: (flags & 1) !== 0 ? c.string.decode(state) : null,
      httpLink: (flags & 2) !== 0 ? c.string.decode(state) : null,
      buffer: (flags & 4) !== 0 ? c.buffer.decode(state) : null,
      mimetype: (flags & 8) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @media/decode-image-response.metadata
const encoding6_0 = encoding2_0

// @media/decode-image-response
const encoding6 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (m.metadata) encoding6_0.preencode(state, m.metadata)
    if (m.data) c.buffer.preencode(state, m.data)
  },
  encode(state, m) {
    const flags = (m.metadata ? 1 : 0) | (m.data ? 2 : 0)

    c.uint.encode(state, flags)

    if (m.metadata) encoding6_0.encode(state, m.metadata)
    if (m.data) c.buffer.encode(state, m.data)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      metadata: (flags & 1) !== 0 ? encoding6_0.decode(state) : null,
      data: (flags & 2) !== 0 ? c.buffer.decode(state) : null
    }
  }
}

// @media/crop-image-request
const encoding7 = {
  preencode(state, m) {
    const flags =
      (version >= 2 && m.path ? 1 : 0) |
      (version >= 2 && m.httpLink ? 2 : 0) |
      (version >= 2 && m.buffer ? 4 : 0) |
      (version >= 2 && m.mimetype ? 8 : 0) |
      (version >= 2 && m.left ? 16 : 0) |
      (version >= 2 && m.top ? 32 : 0) |
      (version >= 2 && m.width ? 64 : 0) |
      (version >= 2 && m.height ? 128 : 0) |
      (version >= 2 && m.format ? 256 : 0)

    c.uint.preencode(state, flags)

    if (version >= 2 && m.path) c.string.preencode(state, m.path)
    if (version >= 2 && m.httpLink) c.string.preencode(state, m.httpLink)
    if (version >= 2 && m.buffer) c.buffer.preencode(state, m.buffer)
    if (version >= 2 && m.mimetype) c.string.preencode(state, m.mimetype)
    if (version >= 2 && m.left) c.uint.preencode(state, m.left)
    if (version >= 2 && m.top) c.uint.preencode(state, m.top)
    if (version >= 2 && m.width) c.uint.preencode(state, m.width)
    if (version >= 2 && m.height) c.uint.preencode(state, m.height)
    if (version >= 2 && m.format) c.string.preencode(state, m.format)
  },
  encode(state, m) {
    const flags =
      (version >= 2 && m.path ? 1 : 0) |
      (version >= 2 && m.httpLink ? 2 : 0) |
      (version >= 2 && m.buffer ? 4 : 0) |
      (version >= 2 && m.mimetype ? 8 : 0) |
      (version >= 2 && m.left ? 16 : 0) |
      (version >= 2 && m.top ? 32 : 0) |
      (version >= 2 && m.width ? 64 : 0) |
      (version >= 2 && m.height ? 128 : 0) |
      (version >= 2 && m.format ? 256 : 0)

    c.uint.encode(state, flags)

    if (version >= 2 && m.path) c.string.encode(state, m.path)
    if (version >= 2 && m.httpLink) c.string.encode(state, m.httpLink)
    if (version >= 2 && m.buffer) c.buffer.encode(state, m.buffer)
    if (version >= 2 && m.mimetype) c.string.encode(state, m.mimetype)
    if (version >= 2 && m.left) c.uint.encode(state, m.left)
    if (version >= 2 && m.top) c.uint.encode(state, m.top)
    if (version >= 2 && m.width) c.uint.encode(state, m.width)
    if (version >= 2 && m.height) c.uint.encode(state, m.height)
    if (version >= 2 && m.format) c.string.encode(state, m.format)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      path: version >= 2 && (flags & 1) !== 0 ? c.string.decode(state) : null,
      httpLink: version >= 2 && (flags & 2) !== 0 ? c.string.decode(state) : null,
      buffer: version >= 2 && (flags & 4) !== 0 ? c.buffer.decode(state) : null,
      mimetype: version >= 2 && (flags & 8) !== 0 ? c.string.decode(state) : null,
      left: version >= 2 && (flags & 16) !== 0 ? c.uint.decode(state) : 0,
      top: version >= 2 && (flags & 32) !== 0 ? c.uint.decode(state) : 0,
      width: version >= 2 && (flags & 64) !== 0 ? c.uint.decode(state) : 0,
      height: version >= 2 && (flags & 128) !== 0 ? c.uint.decode(state) : 0,
      format: version >= 2 && (flags & 256) !== 0 ? c.string.decode(state) : null
    }
  }
}

// @media/crop-image-response.metadata
const encoding8_0 = encoding2_0

// @media/crop-image-response
const encoding8 = {
  preencode(state, m) {
    state.end++ // max flag is 2 so always one byte

    if (version >= 2 && m.metadata) encoding8_0.preencode(state, m.metadata)
    if (version >= 2 && m.data) c.buffer.preencode(state, m.data)
  },
  encode(state, m) {
    const flags = (version >= 2 && m.metadata ? 1 : 0) | (version >= 2 && m.data ? 2 : 0)

    c.uint.encode(state, flags)

    if (version >= 2 && m.metadata) encoding8_0.encode(state, m.metadata)
    if (version >= 2 && m.data) c.buffer.encode(state, m.data)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      metadata: version >= 2 && (flags & 1) !== 0 ? encoding8_0.decode(state) : null,
      data: version >= 2 && (flags & 2) !== 0 ? c.buffer.decode(state) : null
    }
  }
}

// @media/output-parameters
const encoding9 = {
  preencode(state, m) {
    state.end++ // max flag is 8 so always one byte

    if (version >= 3 && m.mimetype) c.string.preencode(state, m.mimetype)
    if (version >= 3 && m.codec) c.string.preencode(state, m.codec)
    if (version >= 3 && m.width) c.uint.preencode(state, m.width)
    if (version >= 3 && m.height) c.uint.preencode(state, m.height)
  },
  encode(state, m) {
    const flags =
      (version >= 3 && m.mimetype ? 1 : 0) |
      (version >= 3 && m.codec ? 2 : 0) |
      (version >= 3 && m.width ? 4 : 0) |
      (version >= 3 && m.height ? 8 : 0)

    c.uint.encode(state, flags)

    if (version >= 3 && m.mimetype) c.string.encode(state, m.mimetype)
    if (version >= 3 && m.codec) c.string.encode(state, m.codec)
    if (version >= 3 && m.width) c.uint.encode(state, m.width)
    if (version >= 3 && m.height) c.uint.encode(state, m.height)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      mimetype: version >= 3 && (flags & 1) !== 0 ? c.string.decode(state) : null,
      codec: version >= 3 && (flags & 2) !== 0 ? c.string.decode(state) : null,
      width: version >= 3 && (flags & 4) !== 0 ? c.uint.decode(state) : 0,
      height: version >= 3 && (flags & 8) !== 0 ? c.uint.decode(state) : 0
    }
  }
}

// @media/transcode-request.outputParameters
const encoding10_4 = c.frame(encoding9)

// @media/transcode-request
const encoding10 = {
  preencode(state, m) {
    state.end++ // max flag is 16 so always one byte

    if (version >= 3 && m.path) c.string.preencode(state, m.path)
    if (version >= 3 && m.httpLink) c.string.preencode(state, m.httpLink)
    if (version >= 3 && m.buffer) c.buffer.preencode(state, m.buffer)
    if (version >= 3 && m.mimetype) c.string.preencode(state, m.mimetype)
    if (version >= 3 && m.outputParameters) encoding10_4.preencode(state, m.outputParameters)
  },
  encode(state, m) {
    const flags =
      (version >= 3 && m.path ? 1 : 0) |
      (version >= 3 && m.httpLink ? 2 : 0) |
      (version >= 3 && m.buffer ? 4 : 0) |
      (version >= 3 && m.mimetype ? 8 : 0) |
      (version >= 3 && m.outputParameters ? 16 : 0)

    c.uint.encode(state, flags)

    if (version >= 3 && m.path) c.string.encode(state, m.path)
    if (version >= 3 && m.httpLink) c.string.encode(state, m.httpLink)
    if (version >= 3 && m.buffer) c.buffer.encode(state, m.buffer)
    if (version >= 3 && m.mimetype) c.string.encode(state, m.mimetype)
    if (version >= 3 && m.outputParameters) encoding10_4.encode(state, m.outputParameters)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      path: version >= 3 && (flags & 1) !== 0 ? c.string.decode(state) : null,
      httpLink: version >= 3 && (flags & 2) !== 0 ? c.string.decode(state) : null,
      buffer: version >= 3 && (flags & 4) !== 0 ? c.buffer.decode(state) : null,
      mimetype: version >= 3 && (flags & 8) !== 0 ? c.string.decode(state) : null,
      outputParameters: version >= 3 && (flags & 16) !== 0 ? encoding10_4.decode(state) : null
    }
  }
}

// @media/transcode-response
const encoding11 = {
  preencode(state, m) {
    state.end++ // max flag is 1 so always one byte

    if (version >= 3 && m.buffer) c.buffer.preencode(state, m.buffer)
  },
  encode(state, m) {
    const flags = version >= 3 && m.buffer ? 1 : 0

    c.uint.encode(state, flags)

    if (version >= 3 && m.buffer) c.buffer.encode(state, m.buffer)
  },
  decode(state) {
    const flags = c.uint.decode(state)

    return {
      buffer: version >= 3 && (flags & 1) !== 0 ? c.buffer.decode(state) : null
    }
  }
}

function setVersion(v) {
  version = v
}

function encode(name, value, v = VERSION) {
  version = v
  return c.encode(getEncoding(name), value)
}

function decode(name, buffer, v = VERSION) {
  version = v
  return c.decode(getEncoding(name), buffer)
}

function getEnum(name) {
  switch (name) {
    default:
      throw new Error('Enum not found ' + name)
  }
}

function getEncoding(name) {
  switch (name) {
    case '@media/dimensions':
      return encoding0
    case '@media/metadata':
      return encoding1
    case '@media/file':
      return encoding2
    case '@media/create-preview-request':
      return encoding3
    case '@media/create-preview-response':
      return encoding4
    case '@media/decode-image-request':
      return encoding5
    case '@media/decode-image-response':
      return encoding6
    case '@media/crop-image-request':
      return encoding7
    case '@media/crop-image-response':
      return encoding8
    case '@media/output-parameters':
      return encoding9
    case '@media/transcode-request':
      return encoding10
    case '@media/transcode-response':
      return encoding11
    default:
      throw new Error('Encoder not found ' + name)
  }
}

function getStruct(name, v = VERSION) {
  const enc = getEncoding(name)
  return {
    preencode(state, m) {
      version = v
      enc.preencode(state, m)
    },
    encode(state, m) {
      version = v
      enc.encode(state, m)
    },
    decode(state) {
      version = v
      return enc.decode(state)
    }
  }
}

const resolveStruct = getStruct // compat

export { resolveStruct, getStruct, getEnum, getEncoding, encode, decode, setVersion, version }
